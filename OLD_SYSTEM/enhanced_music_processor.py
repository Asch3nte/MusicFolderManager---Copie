#!/usr/bin/env python3
"""
Processeur de m√©tadonn√©es am√©lior√© pour MusicFolderManager
Int√®gre extraction compl√®te + d√©tection de fichiers non-originaux
"""

import sys
import os
from pathlib import Path
import logging
from typing import Dict, List, Optional, Tuple, Any

# Ajouter le r√©pertoire parent au path
sys.path.insert(0, str(Path(__file__).parent))

from advanced_metadata_extractor import AdvancedMetadataExtractor
from non_original_detector import NonOriginalDetector
from intelligent_cache import IntelligentCache

class EnhancedMusicProcessor:
    """Processeur de musique avec extraction compl√®te et d√©tection d'authenticit√©"""
    
    def __init__(self, cache_enabled: bool = True):
        self.metadata_extractor = AdvancedMetadataExtractor()
        self.non_original_detector = NonOriginalDetector(tolerance_seconds=2.0)
        self.cache = IntelligentCache() if cache_enabled else None
        
        # Configuration du logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
        
        # Statistiques de traitement
        self.stats = {
            'total_processed': 0,
            'metadata_enhanced': 0,
            'suspicious_files': 0,
            'cache_hits': 0,
            'api_calls': 0,
            'errors': 0
        }
    
    def get_file_audio_properties(self, file_path: str) -> Dict[str, Any]:
        """Extrait les propri√©t√©s audio du fichier"""
        try:
            # Utiliser l'analyseur spectral existant
            from spectral_analyzer import SpectralMatcher
            spectral_matcher = SpectralMatcher()
            
            features = spectral_matcher._extract_features(file_path)
            
            if features:
                return {
                    'duration': features.get('duration', 0),
                    'sample_rate': features.get('sample_rate', 0),
                    'format': features.get('format', ''),
                    'analysis_length': features.get('analysis_length', 0)
                }
            else:
                return {'duration': 0, 'sample_rate': 0, 'format': 'unknown'}
                
        except Exception as e:
            self.logger.error(f"Erreur extraction propri√©t√©s audio {file_path}: {e}")
            return {'duration': 0, 'sample_rate': 0, 'format': 'error'}
    
    def query_music_apis(self, file_path: str, fingerprint_data: Dict = None) -> Dict[str, Any]:
        """Interroge les APIs musicales pour r√©cup√©rer les m√©tadonn√©es compl√®tes"""
        all_metadata = {}
        
        try:
            # V√©rifier le cache d'abord
            if self.cache:
                cached_metadata = self.cache.get_cached_musicbrainz_response('enhanced_lookup', {'file_path': file_path})
                if cached_metadata:
                    self.stats['cache_hits'] += 1
                    return cached_metadata['data']
            
            # 1. Essayer avec AcousticID si on a un fingerprint
            if fingerprint_data and 'fingerprint' in fingerprint_data:
                try:
                    # Simuler une requ√™te AcousticID (remplacer par vraie API)
                    acousticid_response = self._mock_acousticid_api(fingerprint_data)
                    if acousticid_response:
                        acousticid_metadata = self.metadata_extractor.extract_from_acousticid(acousticid_response)
                        all_metadata['acousticid'] = acousticid_metadata
                        self.stats['api_calls'] += 1
                except Exception as e:
                    self.logger.warning(f"Erreur AcousticID: {e}")
            
            # 2. Essayer avec MusicBrainz
            try:
                # Simuler une requ√™te MusicBrainz (remplacer par vraie API)
                musicbrainz_response = self._mock_musicbrainz_api(file_path)
                if musicbrainz_response:
                    musicbrainz_metadata = self.metadata_extractor.extract_from_musicbrainz(musicbrainz_response)
                    all_metadata['musicbrainz'] = musicbrainz_metadata
                    self.stats['api_calls'] += 1
            except Exception as e:
                self.logger.warning(f"Erreur MusicBrainz: {e}")
            
            # 3. Essayer avec Last.fm
            try:
                # Simuler une requ√™te Last.fm (remplacer par vraie API)
                lastfm_response = self._mock_lastfm_api(file_path)
                if lastfm_response:
                    lastfm_metadata = self.metadata_extractor.extract_from_lastfm(lastfm_response)
                    all_metadata['lastfm'] = lastfm_metadata
                    self.stats['api_calls'] += 1
            except Exception as e:
                self.logger.warning(f"Erreur Last.fm: {e}")
            
            # Fusionner toutes les m√©tadonn√©es
            merged_metadata = self.metadata_extractor.merge_metadata(
                all_metadata.get('acousticid', {}),
                all_metadata.get('musicbrainz', {}),
                all_metadata.get('lastfm', {})
            )
            
            # Mettre en cache
            if self.cache and merged_metadata:
                self.cache.cache_musicbrainz_response('enhanced_lookup', {'file_path': file_path}, merged_metadata)
            
            return merged_metadata
            
        except Exception as e:
            self.logger.error(f"Erreur interrogation APIs: {e}")
            self.stats['errors'] += 1
            return {}
    
    def _mock_acousticid_api(self, fingerprint_data: Dict) -> Dict:
        """Mock de l'API AcousticID (remplacer par vraie API)"""
        # En production, faire la vraie requ√™te AcousticID
        return {
            'results': [{
                'recordings': [{
                    'title': 'Example Song',
                    'length': int(fingerprint_data.get('duration', 0) * 1000),
                    'artist-credit': [{'artist': {'name': 'Example Artist'}}],
                    'releases': [{
                        'title': 'Example Album',
                        'date': '2023'
                    }]
                }]
            }]
        }
    
    def _mock_musicbrainz_api(self, file_path: str) -> Dict:
        """Mock de l'API MusicBrainz (remplacer par vraie API)"""
        # En production, faire la vraie requ√™te MusicBrainz
        return {
            'recordings': [{
                'title': Path(file_path).stem,
                'length': 240000,
                'artist-credit': [{'artist': {'name': 'Mock Artist'}}],
                'releases': [{
                    'title': 'Mock Album',
                    'date': '2023-01-01'
                }]
            }]
        }
    
    def _mock_lastfm_api(self, file_path: str) -> Dict:
        """Mock de l'API Last.fm (remplacer par vraie API)"""
        # En production, faire la vraie requ√™te Last.fm
        return {
            'track': {
                'name': Path(file_path).stem,
                'duration': 240000,
                'artist': {'name': 'Mock Artist'},
                'album': {'title': 'Mock Album'},
                'toptags': {
                    'tag': [
                        {'name': 'electronic'},
                        {'name': 'techno'},
                        {'name': 'dance'}
                    ]
                }
            }
        }
    
    def process_audio_file(self, file_path: str) -> Dict[str, Any]:
        """Traitement complet d'un fichier audio"""
        self.stats['total_processed'] += 1
        
        print(f"\nüéµ Traitement: {Path(file_path).name}")
        
        # 1. Extraire les propri√©t√©s audio du fichier
        print("   üìä Extraction propri√©t√©s audio...")
        audio_properties = self.get_file_audio_properties(file_path)
        
        # 2. G√©n√©rer le fingerprint acoustique
        print("   üéß G√©n√©ration fingerprint...")
        fingerprint_data = None
        try:
            from fingerprint.acoustic_matcher import AcousticMatcher
            acoustic_matcher = AcousticMatcher()
            fingerprint_data = acoustic_matcher.generate_fingerprint(file_path)
        except Exception as e:
            self.logger.warning(f"Erreur fingerprint: {e}")
        
        # 3. Interroger les APIs pour r√©cup√©rer les m√©tadonn√©es compl√®tes
        print("   üåê Interrogation APIs musicales...")
        api_metadata = self.query_music_apis(file_path, fingerprint_data)
        
        # 4. Analyser l'authenticit√© du fichier
        print("   üïµÔ∏è Analyse authenticit√©...")
        reference_duration = api_metadata.get('duration', 0)
        actual_duration = audio_properties.get('duration', 0)
        
        # Combiner toutes les m√©tadonn√©es
        combined_metadata = {**audio_properties, **api_metadata}
        
        authenticity_analysis = self.non_original_detector.full_analysis(
            file_path=file_path,
            actual_duration=actual_duration,
            reference_duration=reference_duration,
            metadata=combined_metadata
        )
        
        # 5. Valider la compl√©tude des m√©tadonn√©es
        completeness_report = self.metadata_extractor.validate_metadata_completeness(api_metadata)
        
        # 6. Mettre √† jour les statistiques
        if api_metadata:
            self.stats['metadata_enhanced'] += 1
        
        if authenticity_analysis['suspicion_score'] >= 15:
            self.stats['suspicious_files'] += 1
        
        # 7. Pr√©parer le r√©sultat final
        result = {
            'file_path': file_path,
            'file_name': Path(file_path).name,
            'processing_success': True,
            'audio_properties': audio_properties,
            'fingerprint_data': fingerprint_data,
            'metadata': api_metadata,
            'authenticity_analysis': authenticity_analysis,
            'completeness_report': completeness_report,
            'recommendations': self._generate_recommendations(api_metadata, authenticity_analysis, completeness_report)
        }
        
        # Afficher le r√©sum√©
        self._print_processing_summary(result)
        
        return result
    
    def _generate_recommendations(self, metadata: Dict, authenticity: Dict, completeness: Dict) -> List[str]:
        """G√©n√®re des recommandations bas√©es sur l'analyse"""
        recommendations = []
        
        # Recommandations m√©tadonn√©es
        if completeness['completeness_percentage'] < 70:
            recommendations.append("M√©tadonn√©es incompl√®tes - recherche manuelle recommand√©e")
        
        if not metadata.get('album_artist'):
            recommendations.append("D√©finir l'artiste d'album")
        
        if not metadata.get('year'):
            recommendations.append("Ajouter l'ann√©e de sortie")
        
        if not metadata.get('genre'):
            recommendations.append("Ajouter le genre musical")
        
        if not metadata.get('track_number'):
            recommendations.append("D√©finir le num√©ro de piste")
        
        # Recommandations authenticit√©
        if authenticity['verdict'] in ['highly_suspicious', 'suspicious']:
            recommendations.append("‚ö†Ô∏è Fichier possiblement non-original - v√©rification manuelle recommand√©e")
        
        if authenticity['verdict'] == 'questionable':
            recommendations.append("Qualit√© du fichier douteuse")
        
        # Recommandations techniques
        if metadata.get('sample_rate', 0) < 44100:
            recommendations.append("Sample rate bas - qualit√© limit√©e")
        
        if metadata.get('bitrate', 0) < 160:
            recommendations.append("Bitrate bas - compression √©lev√©e")
        
        return recommendations
    
    def _print_processing_summary(self, result: Dict) -> None:
        """Affiche un r√©sum√© du traitement"""
        metadata = result['metadata']
        authenticity = result['authenticity_analysis']
        completeness = result['completeness_report']
        
        print(f"   üìã M√©tadonn√©es:")
        print(f"      Titre: {metadata.get('title', 'N/A')}")
        print(f"      Artiste: {metadata.get('artist', 'N/A')}")
        print(f"      Album: {metadata.get('album', 'N/A')}")
        print(f"      Artiste album: {metadata.get('album_artist', 'N/A')}")
        print(f"      Ann√©e: {metadata.get('year', 'N/A')}")
        print(f"      Genre: {metadata.get('genre', 'N/A')}")
        print(f"      Piste: {metadata.get('track_number', 'N/A')}")
        
        print(f"   üìä Compl√©tude: {completeness['completeness_percentage']:.1f}%")
        print(f"   üïµÔ∏è Authenticit√©: {authenticity['verdict_text']} (Score: {authenticity['suspicion_score']})")
        
        if result['recommendations']:
            print(f"   üí° Recommandations:")
            for rec in result['recommendations'][:3]:  # Top 3
                print(f"      ‚Ä¢ {rec}")
    
    def generate_processing_report(self, output_dir: str) -> Dict[str, str]:
        """G√©n√®re un rapport de traitement"""
        # G√©n√©rer le rapport de d√©tection de fichiers non-originaux
        non_original_reports = self.non_original_detector.generate_report(output_dir)
        
        # Cr√©er un rapport de statistiques de traitement
        stats_report_path = Path(output_dir) / "processing_statistics.txt"
        with open(stats_report_path, 'w', encoding='utf-8') as f:
            f.write("üìä RAPPORT DE TRAITEMENT MUSICFOLDERMANAGER\n")
            f.write("=" * 60 + "\n\n")
            f.write(f"üìà STATISTIQUES G√âN√âRALES:\n")
            f.write(f"   ‚Ä¢ Fichiers trait√©s: {self.stats['total_processed']}\n")
            f.write(f"   ‚Ä¢ M√©tadonn√©es am√©lior√©es: {self.stats['metadata_enhanced']}\n")
            f.write(f"   ‚Ä¢ Fichiers suspects: {self.stats['suspicious_files']}\n")
            f.write(f"   ‚Ä¢ Utilisations du cache: {self.stats['cache_hits']}\n")
            f.write(f"   ‚Ä¢ Appels API: {self.stats['api_calls']}\n")
            f.write(f"   ‚Ä¢ Erreurs: {self.stats['errors']}\n\n")
            
            if self.stats['total_processed'] > 0:
                f.write(f"üìä RATIOS:\n")
                f.write(f"   ‚Ä¢ Taux d'am√©lioration m√©tadonn√©es: {(self.stats['metadata_enhanced']/self.stats['total_processed']*100):.1f}%\n")
                f.write(f"   ‚Ä¢ Taux de fichiers suspects: {(self.stats['suspicious_files']/self.stats['total_processed']*100):.1f}%\n")
                f.write(f"   ‚Ä¢ Efficacit√© cache: {(self.stats['cache_hits']/(self.stats['cache_hits']+self.stats['api_calls'])*100):.1f}%\n")
        
        return {
            'processing_stats': str(stats_report_path),
            **non_original_reports
        }

def test_enhanced_processor():
    """Test du processeur am√©lior√©"""
    processor = EnhancedMusicProcessor()
    
    # Test avec un fichier d'exemple
    test_file = "test_audio.mp3"
    
    print("üß™ Test du processeur de m√©tadonn√©es am√©lior√©")
    print("=" * 60)
    
    # Simuler le traitement
    result = processor.process_audio_file(test_file)
    
    print(f"\nüìä R√©sum√© du test:")
    print(f"   Succ√®s: {result['processing_success']}")
    print(f"   Recommandations: {len(result['recommendations'])}")
    
    # G√©n√©rer un rapport
    reports = processor.generate_processing_report("test_output")
    print(f"\nüìÑ Rapports g√©n√©r√©s:")
    for report_type, path in reports.items():
        print(f"   {report_type}: {path}")

if __name__ == "__main__":
    test_enhanced_processor()
